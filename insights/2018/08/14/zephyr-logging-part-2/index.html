<!doctype html><html class=no-js lang=en-us><head><link rel=preconnect href=https://cdnjs.cloudflare.com><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com><link rel=preconnect href=https://www.googletagmanager.com><meta charset=utf-8><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Zephyr Logging Survival Guide, Part 2: Logger Subsystem | Foundries.io</title><link rel="shortcut icon" href=/images/icons/favicon.ico><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Lato:300,400,500,700,900"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css integrity="sha256-eZrrJcwDc/3uDhsdt61sL2oOBY362qM3lon1gyExkL0=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.0/animate.min.css integrity="sha256-HtCCUh9Hkh//8U1OwcbD8epVEUdBvuI8wj1KtqMhNkI=" crossorigin=anonymous><link rel=stylesheet href=/css/foundation.min.228f9b8bdf4aae06e794eb13011f0858c2d27f9d39a55e09bbe84ff4bc8644c4.css><link rel=stylesheet href=/style.insights.bundle.min.f573bbc4406b603c54dffb8cb02ac46a639dd4395e045de4bf1b071b3a1ffed2.css></head><body><div class="top sticky"><div class=row><div class="small-12 large-3 medium-3 columns"><div class=logo><a href=/><img src=/images/logo.png alt="Foundries.io logo"></a></div></div><div class="small-12 large-9 medium-9 columns"><nav class=desktop-menu><ul class=sf-menu id=navigation><li><a href=/>HOME</a></li><li><a href=/products/>PRODUCTS</a><ul class=nav-menu><li><a href=/products/>MICROPLATFORMS</a></li><li><a href=/pricing/>PRICING</a></li><li><a href=/hardware/>HARDWARE</a></li><li><a href=/terms/>TERMS &amp; CONDITIONS</a></li></ul></li><li><a href=/partners/>PARTNERS</a><ul class=nav-menu><li><a href=/partners/>PARTNER PROGRAM</a></li><li><a href=/partners/all/>OUR PARTNERS</a></li></ul></li><li><a href=/insights/>INSIGHTS</a><ul class=nav-menu><li><a href=/insights/>BLOG</a></li><li><a href=/categories/updates/>UPDATES</a></li></ul></li><li><a href=/company/>ABOUT</a><ul class=nav-menu><li><a href=/company/>COMPANY</a></li><li><a href=/labs/>LABS</a></li><li><a href=/careers/>CAREERS</a></li></ul></li><li><a href="https://app.foundries.io/login/?next=/"><i class="fa fa-cloud-upload"></i>&nbsp;ENGAGE</a><ul class=nav-menu><li><a href=https://app.foundries.io/docs/>DOCUMENTATION</a></li><li><a href="https://app.foundries.io/login/?next=/">DASHBOARD</a></li><li><a href=https://forums.foundries.io>FORUMS</a></li><li><a href=https://support.foundries.io>SUPPORT</a></li><li><a href=https://join.slack.com/t/foundriesio/shared_invite/enQtNTc5NDkxNTI5NTExLTU1YzI3YWFmZTI3ZjRjOTExZDZjYWFmMDNjZDBjYjczYTYzZWE0ZWYxYWVjMGZhYjNjN2MyMDVhMzY5NWNlNDE>SLACK</a></li><li><a href="https://app.foundries.io/login/?next=/">GET STARTED</a></li></ul></li></ul></nav></div></div></div><header class=alt-6><div class=message><div class=row><div class="small-12 columns"><div class=message-intro><span class=message-line></span><p>FOUNDRIES.IO INSIGHTS</p><span class=message-line></span></div><h1>Zephyr Logging Survival Guide, Part 2: Logger Subsystem</h1><p class="text-muted text-uppercase mb-small text-right color-white">By Marti Bolivar&nbsp;|
August 14, 2018</p></div></div></div></header><div id=content><div class=container><div class=row><div class="small-12 columns" id=insights-post><div id=post-content><p>An overview of the new logging system merged for v1.13, or: <em>Can&rsquo;t Get
Enough of your Logs, Zephyr</em>.</p><p>In <a href=https://foundries.io/insights/2018/07/24/zephyr-logging-part-1/>part one</a> of this series,
we described Zephyr&rsquo;s venerable SYS_LOG logging API. While it has
(mostly) served us well, there&rsquo;s a brand new alternative: a &ldquo;Logger&rdquo;
subsystem was recently merged into master, and will be part of the
v1.13 release. We&rsquo;ll explore it in detail in this second and
final part, comparing and contrasting it with SYS_LOG.</p><p>Console output is from <a href=https://github.com/zephyrproject-rtos/zephyr/tree/55327a183d8004c6d113f14c91a2f8813e3e1317>Zephyr
55327a183</a>
on the <code>nrf52840_pca10056</code> board. <a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13>Complete application source
code</a>
for all examples is available.</p><p>Contents:</p><nav id=TableOfContents><ul><li><a href=#basic-usage>Basic Usage</a></li><li><a href=#so-many-fancy-features>So Many Fancy Features</a></li><li><a href=#interlude-who-will-time-the-timestamps-themselves>Interlude: Who Will Time the Timestamps Themselves?</a><ul><li><a href=#logger-timestamps-vs-message-print-times>Logger Timestamps vs. Message Print Times</a></li><li><a href=#comparison-with-sys-log>Comparison with SYS_LOG</a></li><li><a href=#on-screen>On Screen!</a></li><li><a href=#what-the-heck>What the Heck?</a></li></ul></li><li><a href=#deferred-logging>Deferred Logging</a><ul><li><a href=#going-faster-trigger-threshold-and-sleep-time>Going Faster: Trigger Threshold and Sleep Time</a></li><li><a href=#pulling-the-fire-alarm-panic-mode>Pulling the Fire Alarm: Panic Mode</a></li><li><a href=#escape-hatch-processing-messages-yourself>Escape Hatch: Processing Messages Yourself</a></li></ul></li><li><a href=#timestamps>Timestamps</a></li><li><a href=#binary-data-dumping>Binary Data Dumping</a></li><li><a href=#module-filtering>Module Filtering</a><ul><li><a href=#compile-time>Compile Time</a></li><li><a href=#run-time-advanced>Run Time (Advanced)</a></li></ul></li><li><a href=#quirks-and-gotchas>Quirks and Gotchas</a><ul><li><a href=#grab-bag>Grab Bag</a></li><li><a href=#logging-strings>Logging Strings</a></li><li><a href=#overflow>Overflow</a></li></ul></li><li><a href=#summary>Summary</a></li><li><a href=#additional-resources>Additional Resources</a></li></ul></nav><h1 id=basic-usage>Basic Usage</h1><p>At first blush, using Logger isn&rsquo;t that different from SYS_LOG:</p><ol><li>set a log level (one of <code>LOG_LEVEL_NONE</code>, <code>LOG_LEVEL_DBG</code>, <code>LOG_LEVEL_INF</code>,
<code>..._WRN</code>, <code>..._ERR</code>)</li><li>set a &ldquo;module&rdquo; name (more on this later)</li><li>include <code>&lt;logging/log.h&gt;</code></li><li>perform some module-specific initialization</li><li>log the logs!</li></ol><p>Logger has printf()-like macros <code>LOG_DBG</code>, <code>LOG_INF</code>, <code>LOG_WRN</code>, and
<code>LOG_ERR</code>, which work the way you&rsquo;d expect.</p><p>Example code (<a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/logger_basics>full source on GitHub</a>):</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#998;font-style:italic>/* Display all messages, including debugging ones, in this file: */</span>
<span style=color:#999;font-weight:700;font-style:italic>#define LOG_LEVEL LOG_LEVEL_DBG
</span><span style=color:#999;font-weight:700;font-style:italic></span>
<span style=color:#998;font-style:italic>/* Set the &#34;module&#34; for log messages in this file: */</span>
<span style=color:#999;font-weight:700;font-style:italic>#define LOG_MODULE_NAME foundries_io_basics
</span><span style=color:#999;font-weight:700;font-style:italic></span>
<span style=color:#999;font-weight:700;font-style:italic>#include</span> <span style=color:#999;font-weight:700;font-style:italic>&lt;logging/log.h&gt;</span><span style=color:#999;font-weight:700;font-style:italic>
</span><span style=color:#999;font-weight:700;font-style:italic></span>
<span style=color:#998;font-style:italic>/* Initialize module-specific magic state (once per module name): */</span>
LOG_MODULE_REGISTER();

<span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>main</span>(<span style=color:#458;font-weight:700>void</span>)
{
	LOG_DBG(<span style=color:#d14>&#34;verbose debug %d&#34;</span>, <span style=color:#099>3</span>);
	LOG_INF(<span style=color:#d14>&#34;everything is fine, mask=0x%x&#34;</span>, <span style=color:#099>0xa1</span>);
	LOG_WRN(<span style=color:#d14>&#34;warning: %s was seen&#34;</span>, <span style=color:#d14>&#34;something bad&#34;</span>);
	LOG_ERR(<span style=color:#d14>&#34;error %d&#34;</span>, <span style=color:#099>3</span>);
}</code></pre></div><p>Output screenshot:</p><p><img src=/uploads/2018/07/23/logger_basics.png alt></p><p>The output is formatted as follows:</p><pre><code>[TIMESTAMP] &lt;LEVEL&gt; &lt;MODULE&gt;: formatted_message + \n
</code></pre><p>Like SYS_LOG, the Logger subsystem&rsquo;s output (by default):</p><ul><li>goes to the console UART</li><li>includes the formatted message</li><li>automatically appends a newline</li><li>prints the &ldquo;module&rdquo; (which is somewhat similar to a SYS_LOG domain)</li></ul><p><strong>Unlike SYS_LOG</strong>, however:</p><ul><li>By default, output includes timestamps and is colorized (hurray!).</li><li>The name of the function which logged the message is not included
in the output. You can of course add it yourself, e.g. with
<code>LOG_INF(&quot;%s: hi there&quot;, __func__)</code>.</li><li><strong>Module names must be valid C identifiers</strong> (they can also begin
with a digit), rather than arbitrary strings: so
<code>foundries_io_basics</code> is OK, but <code>foundries.io/basics</code> will cause a
cryptic compilation error. This is a &ldquo;gotcha&rdquo; for SYS_LOG users,
since upstream Zephyr uses a slash (<code>/</code>) for namespacing in SYS_LOG
domains.</li></ul><p>Yawn&hellip; OK, so what&rsquo;s the big deal? That&rsquo;s not a huge difference; why
introduce a whole new subsystem?</p><h1 id=so-many-fancy-features>So Many Fancy Features</h1><p>Logger has several features not present in the more basic
SYS_LOG. We&rsquo;ll dig into these in particular:</p><ul><li>Deferred logging</li><li>Timestamps</li><li>Binary data dumping</li><li>Module filtering</li></ul><p>We&rsquo;ll describe Logger&rsquo;s quirks and sharp edges as well.</p><p>There are a few Logger features we won&rsquo;t evaluate:</p><ul><li>Instance logging: we&rsquo;re curious to kick the tires on this feature,
but weren&rsquo;t able to get to it due to time constraints.</li><li>Multiple backends: at time of writing, only UART logging is
supported. Additional logging destinations (like network or flash
logging) may be added later on &ndash; this is an opportunity to contribute to
Zephyr!</li><li>Multi-domain/multi-processor readiness: the Logger subsystem was
designed for use with those newfangled multi-core environments
Zephyr has been adding support for lately. We&rsquo;ve only got Zephyr running on
humble single-core MCUs on our desk, though. And anyways, multi-core is for
running Linux, right?</li><li>Logger as a printk() backend: enabling
<a href=http://docs.zephyrproject.org/reference/kconfig/CONFIG_LOG_PRINTK.html>CONFIG_LOG_PRINTK</a>
redirects printk() output to the Logger. Good to know, but we&rsquo;re
happy with <code>printk()</code> as a nice, simple way to write to the UART
console.</li></ul><h1 id=interlude-who-will-time-the-timestamps-themselves>Interlude: Who Will Time the Timestamps Themselves?</h1><p>If you&rsquo;ll permit the digression.</p><p>Before we dig any deeper into Logger&rsquo;s other features, we&rsquo;ll analyze
its basic behavior further, comparing it with an <a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/sys_log_basics>equivalent SYS_LOG
example</a>
from part 1.</p><p>This will help explain things, promise.</p><h2 id=logger-timestamps-vs-message-print-times>Logger Timestamps vs. Message Print Times</h2><p>First, let&rsquo;s take a close look at the timestamps Logger printed:</p><p><img src=/uploads/2018/07/23/logger_basics_tstamps.png alt></p><p>Wait&hellip; the four messages all &ldquo;happened&rdquo; in the <strong>very same
microsecond</strong>? (Readers who need further convincing regarding the
decimal separator format are referred to
<a href=https://github.com/zephyrproject-rtos/zephyr/blob/7fe2c3b14fde28419dbd0e877c98c0ccf576d3da/subsys/logging/log_output.c#L112>log_output.c</a>.)</p><p>The above screenshot is of output from a UART console at the usual
115200 baud, 8N1 setting. It takes at least 86 microseconds to output
a single character at that speed, so the <code>LOG_XXX</code> macros definitely
aren&rsquo;t sitting around polling the UART, the way their SYS_LOG
equivalents do: the timestamp calculation has to be happening before
anything gets printed.</p><p>Readers who are playing along at home will also have noticed a
significant delay between Zephyr&rsquo;s boot banner and the appearance of
the first log message. This can be seen by capturing the serial output
using <a href=https://elinux.org/Grabserial>grabserial</a> in timestamp mode,
like so:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>$ grabserial -t -b <span style=color:#099>115200</span> -d /dev/serial-port-device</code></pre></div><p>On this system, the output was (with ASCII art notes on the grabserial
timestamps):</p><pre><code> +-- Rough timestamp since first character, in seconds
 |
 |        +--- Relative timestamp since last line, in seconds
 |        |
 v        v
[0.000001 0.000001] ***** Booting Zephyr OS v1.12.0-1181-g55327a183 *****
          +--- Huh?! Over a second elapses between boot banner and first log!
          |
          v
[1.007872 1.007871] [00:00:00.003,662] &lt;dbg&gt; foundries_io_basics: verbose debug 3

          +--- Next log messages appear quickly thereafter.
          |
          v
[1.012974 0.005102] [00:00:00.003,662] &lt;inf&gt; foundries_io_basics: everything is fine, mask=0xa1
[1.019813 0.006839] [00:00:00.003,662] &lt;wrn&gt; foundries_io_basics: warning: something bad was seen
[1.027559 0.007746] [00:00:00.003,662] &lt;err&gt; foundries_io_basics: error 3
</code></pre><p>What&rsquo;s up with that <strong>entire extra second</strong> of delay after <code>Booting
Zephyr OS</code> but before the first log message? Is Logger doing some
heavy-duty initialization, or is something else going on?</p><h2 id=comparison-with-sys-log>Comparison with SYS_LOG</h2><p>Though SYS_LOG doesn&rsquo;t print timestamps, we can capture print times
with grabserial. Sure enough, SYS_LOG messages start printing right away:</p><pre><code>[0.000001 0.000001] ***** Booting Zephyr OS v1.12.0-1181-g55327a183 *****
          +--- No significant delay here.
          |
          v
[0.004089 0.004088] [foundries.io/basics] [DBG] main: verbose debug 3
[0.008852 0.004763] [foundries.io/basics] [INF] main: everything is fine, mask=0xa1
[0.014059 0.005207] [foundries.io/basics] [WRN] main: warning: something bad was seen
[0.020125 0.006066] [foundries.io/basics] [ERR] main: error 3
</code></pre><h2 id=on-screen>On Screen!</h2><p>Let&rsquo;s see the default timing in detail by generating some pulses on a
GPIO pin at the same time as doing some Logger calls:</p><ul><li>One pulse with a few NOPs in between, to get a baseline</li><li>Two consecutive pulses wrapping a <code>LOG_DBG(&quot;&quot;)</code> invocation, for rough figures of merit</li></ul><p>This is the overall result:</p><p><img src=/uploads/2018/07/23/logger_pulses_timing.png alt></p><p>Pulse generation code (<a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/logger_gpio_pulses>full source on
GitHub</a>)
follows.</p><p>The first pulse is done with a few NOPs in between, just to get a
rough idea of pulse behavior:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>NRF_P0<span style=color:#000;font-weight:700>-&gt;</span>OUTSET <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1U</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> PIN;
__NOP();
__NOP();
__NOP();
NRF_P0<span style=color:#000;font-weight:700>-&gt;</span>OUTCLR <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1U</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> PIN;</code></pre></div><p>The next two pulses wrap <code>LOG_DBG(&quot;&quot;)</code> calls. This may underestimate
the true cost to log a message, as the compiler could move some code
outside of the <code>OUTSET</code>/<code>OUTCLR</code> lines, but it&rsquo;s a good-enough
approximation:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>NRF_P0<span style=color:#000;font-weight:700>-&gt;</span>OUTSET <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1U</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> PIN;
LOG_DBG(<span style=color:#d14>&#34;&#34;</span>);
NRF_P0<span style=color:#000;font-weight:700>-&gt;</span>OUTCLR <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1U</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> PIN;

NRF_P0<span style=color:#000;font-weight:700>-&gt;</span>OUTSET <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1U</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> PIN;
LOG_DBG(<span style=color:#d14>&#34;&#34;</span>);
NRF_P0<span style=color:#000;font-weight:700>-&gt;</span>OUTCLR <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1U</span> <span style=color:#000;font-weight:700>&lt;&lt;</span> PIN;</code></pre></div><p>(Generously) accounting for slew rate, the first pulse is in the
neighborhood of 100 ns, which puts pulse overhead in the noise:</p><p><img src=/uploads/2018/07/23/logger_pulses_timing_first.png alt></p><p>Subsequent pulses are a bit over 4 microseconds:</p><p><img src=/uploads/2018/07/23/logger_pulses_timing_dbg.png alt></p><p>So, at least on this board, there are only about 4 microseconds of
overhead to prepare and buffer a basic log message. <strong>Sweet!</strong> That&rsquo;ll
work great in our IRQs.</p><p>&hellip; Wait a minute, though: the messages&rsquo; logged timestamps agree to
the microsecond in the UART output, but they should be about 5
microseconds apart in real time. Gotcha:</p><p><strong>Logger timestamps are printed to the microsecond, but are (probably)
not accurate to the microsecond.</strong></p><p>The nRF52840 SoC we&rsquo;re using for our testing has a timer driver with
maximum resolution of about 30 microseconds. Since we observed 4-5
microseconds of overhead to prepare each Logger message, it makes
sense that four back-to-back messages could have the same timestamp:</p><p>(5 μsec / message) * (4 messages) = 20 μsec &lt; 30 μsec</p><p>(Incidentally, further testing showed that just getting the timestamp
itself takes a little bit more than a microsecond on this part.)</p><p>On other ARM Cortex-M SoCs, timestamp accuracy is likely to be limited
by the SysTick peripheral&rsquo;s resolution. Elsewhere, your mileage will
vary.</p><p>We&rsquo;ll briefly discuss Logger&rsquo;s mechanisms for using more accurate
timers, if your hardware has them, below.</p><p>Where&rsquo;s the UART output? Taking out the logic analyzer, sure enough,
it appears about a second later (the near-invisibly-thin line on
channel 0 is the sequence of three pulses from earlier):</p><p><img src=/uploads/2018/07/23/logger_pulses_uart.png alt></p><h2 id=what-the-heck>What the Heck?</h2><p><strong>Unlike SYS_LOG, Logger captures timestamps and prepares log messages
for later printing in another thread.</strong></p><p>This is called <em>deferred logging</em> in the official documentation, which
further reads:</p><blockquote><p>Logger is designed to be thread safe and minimizes time needed to log
the message. Time consuming operations like string formatting or
access to the transport are not performed by default when logger API
is called. When logger API is called a message is created and added to
the list. Dedicated, configurable pool of log messages is used.</p></blockquote><p>In other words, macros like <code>LOG_ERR()</code> don&rsquo;t print anything; instead,
they make a note of information to be printed at some point later on.
The timing above is from Logger&rsquo;s default configuration for what
&ldquo;later on&rdquo; means. (This can be tuned, as we&rsquo;ll see&hellip; later on.)</p><h1 id=deferred-logging>Deferred Logging</h1><p>The default deferred logging behavior shown above can be fine-tuned
with some Go Faster knobs, and also has an Emergency We&rsquo;re On Fire
Print Everything <em>Right Now</em> mode. If you need further control, there
are escape hatches to allow the application to determine all details
of when log messages are handled.</p><h2 id=going-faster-trigger-threshold-and-sleep-time>Going Faster: Trigger Threshold and Sleep Time</h2><p>Let&rsquo;s talk about the Go Faster sliders first, as pulling the fire
alarm has serious consequences.</p><p>By default, Logger creates a <a href=https://github.com/zephyrproject-rtos/zephyr/blob/7fe2c3b14fde28419dbd0e877c98c0ccf576d3da/subsys/logging/log_core.c#L460>low-priority background
thread</a>
that actually prints messages, and starts it up at boot time. This
thread wakes up and processes messages when either of the following
things happens:</p><ul><li><a href=http://docs.zephyrproject.org/reference/kconfig/CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD.html>CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD</a>
messages are buffered for printing (this defaults to 10, which is more than
we queued, so the threshold was not met)</li><li><a href=http://docs.zephyrproject.org/reference/kconfig/CONFIG_LOG_PROCESS_THREAD_SLEEP_MS.html>CONFIG_LOG_PROCESS_THREAD_SLEEP_MS</a>
milliseconds elapse (this value defaults to 1000, explaining the roughly 1
second delay between boot banner and first message)</li></ul><p>These options exist for users to tweak the background thread&rsquo;s
behavior.</p><p>Setting <code>CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD=2</code> in prj.conf and using
grabserial, we see a shorter delay (<a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/logger_low_threshold>full source on
GitHub</a>):</p><pre><code>[0.003972 0.003970] main() started
[0.005874 0.001902] [00:00:00.005,065] &lt;dbg&gt; foundries_io_threshold: verbose debug 3
</code></pre><p>(Here, we&rsquo;ve switched to a &ldquo;main() started&rdquo; printk() call to help
disambiguate time spent by Zephyr between printing the boot banner and
calling <code>main()</code>, now that we&rsquo;re paying closer attention to timing.)</p><p>Likewise, setting <code>CONFIG_LOG_PROCESS_THREAD_SLEEP_MS=500</code> also
decreases the delay to just over half a second (<a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/logger_low_sleep>full source on
GitHub</a>):</p><pre><code>[66.731052 0.004132] main() started
[67.235140 0.504088] [00:00:00.005,126] &lt;dbg&gt; foundries_io_sleep: verbose debug 3
</code></pre><h2 id=pulling-the-fire-alarm-panic-mode>Pulling the Fire Alarm: Panic Mode</h2><p>As discussed in part 1, one benefit to SYS_LOG&rsquo;s simplicity is that a
polling UART implementation is exceedingly difficult to break. This is
extremely useful for printing last gasp messages in fatal error
handlers, if, say, the scheduler&rsquo;s memory gets hopelessly corrupted
and deferring logs to another thread wouldn&rsquo;t work.</p><p>To cover situations like this, Logger has a &ldquo;panic mode&rdquo;. If you call
the <code>LOG_PANIC()</code> macro (defined in <code>&lt;logging/log_ctrl.h&gt;</code>):</p><ul><li>all pending messages are flushed</li><li>deferred logging is permanently disabled; all further Logger calls are
handled synchronously</li></ul><p>A couple of notes:</p><ul><li>the upstream documentation currently covers the
<a href=http://docs.zephyrproject.org/subsystems/logging/logger.html#logger-panic>log_panic()</a>
function instead of <code>LOG_PANIC()</code>, but the macro has the nice
property of compiling away when logging is disabled, so we recommend
using it instead.</li><li>Since <code>LOG_PANIC()</code> flushes all pending messages, among other
things, the call itself can take a long time to print existing messages
out on the UART.</li></ul><h2 id=escape-hatch-processing-messages-yourself>Escape Hatch: Processing Messages Yourself</h2><p>Finally, if none of the above work for you, you can disable
<a href=http://docs.zephyrproject.org/reference/kconfig/CONFIG_LOG_PROCESS_THREAD.html>CONFIG_LOG_PROCESS_THREAD</a>
entirely and take control over when messages are printed.</p><p>The
<a href=http://docs.zephyrproject.org/api/logger_api.html#logger-control>&lt;logger/log_ctrl.h&gt;</a>
APIs allow this. Pointers for getting started:</p><ul><li>Call <code>log_init()</code> during system initialization, to finish logger
setup.</li><li>Call <code>log_process()</code> regularly to dequeue and print messages.</li><li>If you want to support trigger thresholds as described above, you
should also call <code>log_thread_set()</code> with the thread ID of your
processing thread. The logger core will wake it from sleep when
the threshold is crossed.</li></ul><h1 id=timestamps>Timestamps</h1><p>Logger prints timestamps down to the microsecond level. By default,
<a href=https://github.com/zephyrproject-rtos/zephyr/blob/7fe2c3b14fde28419dbd0e877c98c0ccf576d3da/subsys/logging/log_core.c#L190>it uses
k_cycle_get_32()</a>
to fetch the timestamps themselves. Despite the name, this is often
not a cycle-accurate timer &ndash; you&rsquo;ll need to check the implementation
on your platform to be sure.</p><p>As a rule of thumb, it&rsquo;s best to ignore the pieces of the timestamp
below the millisecond range unless you know what you&rsquo;re doing.</p><p>If you need higher-resolution timestamps than the default setting and
have an accurate timer, you <em>can</em> use
<a href=http://docs.zephyrproject.org/api/logger_api.html#_CPPv322log_set_timestamp_func15timestamp_get_t5u32_t>log_set_timestamp_func()</a>
to override Logger&rsquo;s default settings.</p><p>However, <strong>it&rsquo;s probably not worth going crazy</strong> trying to achieve
microsecond accuracy in most cases, since preparing even simple log
messages already takes a few microseconds on a microcontroller. If you
truly need sub-microsecond accuracy, then system trace peripherals,
GPIOs, etc. remain your friends.</p><h1 id=binary-data-dumping>Binary Data Dumping</h1><p>Sometimes, it&rsquo;s the little things.</p><p>SYS_LOG doesn&rsquo;t have a way to dump binary data. Use it for long
enough, and you&rsquo;ll end up rolling your own hexdump wrappers, which you
have to copy/paste around, especially if you&rsquo;re debugging upstream
code. A minor inconvenience, but one nonetheless.</p><p>Thankfully, Logger has an answer for this
(<a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/logger_dumping>full source on GitHub</a>):</p><pre><code class=language-c>unsigned char data[] = {0xde, 0xad, 0xbe, 0xef,
			'd', 'e', 'a', 'd',
			'b', 'e', 'e', 'f',
			0xde, 0xad, 0xbe, 0xef};

LOG_HEXDUMP_INF(data, sizeof(data));
</code></pre><p>Output (note hex and ASCII are both present):</p><pre><code>[00:00:00.004,638] &lt;inf&gt; foundries_io_dumping:  de ad be ef 64 65 61 64|....dead
                                                62 65 65 66 de ad be ef|beef....
</code></pre><p>There are <code>LOG_HEX_DUMP_ERR()</code>, <code>..._WRN()</code>, and <code>..._DBG()</code> variants
as well, of course.</p><p>When using this feature, it&rsquo;s <strong>important to be aware</strong> that data are
copied into log message buffers until they can be processed. This
memory comes from the same pool as all other messages, so logging long
blobs can cause you to run out of space for other messages.</p><p>We&rsquo;ll discuss what happens in cases of overflow in the Quirks and
Gotchas section below.</p><h1 id=module-filtering>Module Filtering</h1><p>Logger supports compile and run time filtering of each module&rsquo;s logs.</p><p>What is a module, you may ask? When you see <em>module</em>, think of
<em>modular programming</em>. Potential examples:</p><ul><li>blocks on your block diagram</li><li>the part of your application that captures sensor data</li><li>a subsystem (like USB)</li><li>the core kernel</li></ul><p>If you&rsquo;re unsure of how to break your application into modules, here
are some suggestions to get started:</p><ul><li>one module per file (named for the file) or subdirectory of <code>src/</code>
(named for the directory)</li><li>one module for your entire application (named for your app)</li></ul><h2 id=compile-time>Compile Time</h2><p>Logger can do compile-time filtering of log calls by verbosity level
on a per-file basis (or per-module basis, if you set it up nicely)
through use of the <code>LOG_LEVEL</code> macro.</p><p>It&rsquo;s usually worth taking the time to set up a Kconfig option to
control a module&rsquo;s log level. This is especially true if your module
is going into upstream Zephyr, or if it&rsquo;s split into multiple files.</p><p>Example code for how to set up and use a log level Kconfig option
follows. As usual, you can find <a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/logger_module_filtering>full source on
GitHub</a>,
and that&rsquo;s especially worth checking out here, since you also need to
make some CMakeLists.txt and Kconfig file changes as documented in the
<a href=http://docs.zephyrproject.org/application/application.html#application-cmakelists-txt>Application Development
Primer</a>.</p><p>In <code>module_main_file.c</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#999;font-weight:700;font-style:italic>#define LOG_LEVEL CONFIG_FOUNDRIES_IO_MOD_LOG_LEVEL
</span><span style=color:#999;font-weight:700;font-style:italic>#define LOG_MODULE_NAME foundries_io_mod
</span><span style=color:#999;font-weight:700;font-style:italic>#include</span> <span style=color:#999;font-weight:700;font-style:italic>&lt;logging/log.h&gt;</span><span style=color:#999;font-weight:700;font-style:italic>
</span><span style=color:#999;font-weight:700;font-style:italic></span>LOG_MODULE_REGISTER();

<span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>module_init</span>(<span style=color:#458;font-weight:700>void</span>)
{
	LOG_INF(<span style=color:#d14>&#34;initialized; getting help.&#34;</span>);
	module_get_help();
}</code></pre></div><p>In <code>module_helper_file.c</code>:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#999;font-weight:700;font-style:italic>#define LOG_LEVEL CONFIG_FOUNDRIES_IO_MOD_LOG_LEVEL
</span><span style=color:#999;font-weight:700;font-style:italic>#define LOG_MODULE_NAME foundries_io_mod
</span><span style=color:#999;font-weight:700;font-style:italic>#include</span> <span style=color:#999;font-weight:700;font-style:italic>&lt;logging/log.h&gt;</span><span style=color:#999;font-weight:700;font-style:italic>
</span><span style=color:#999;font-weight:700;font-style:italic></span>
<span style=color:#998;font-style:italic>/*
</span><span style=color:#998;font-style:italic> * Note LOG_MODULE_DECLARE() is used instead of LOG_MODULE_REGISTER().
</span><span style=color:#998;font-style:italic> * Exactly one file registers the module. The other files in the
</span><span style=color:#998;font-style:italic> * module still need to declare module-specific state before using
</span><span style=color:#998;font-style:italic> * logger APIs.
</span><span style=color:#998;font-style:italic> */</span>
LOG_MODULE_DECLARE();

<span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>module_get_help</span>()
{
	LOG_DBG(<span style=color:#d14>&#34;i&#39;m trying to help!&#34;</span>);
}</code></pre></div><p>Default output:</p><pre><code>[00:00:00.003,753] &lt;inf&gt; foundries_io_mod: initialized; getting help.
[00:00:00.003,753] &lt;dbg&gt; foundries_io_mod: i'm trying to help!
</code></pre><p>If we set <code>CONFIG_FOUNDRIES_IO_MOD_LOG_LEVEL=3</code> (INF) in prj.conf,
rebuild, and reflash, the <code>&lt;dbg&gt;</code> message disappears and the output
is:</p><pre><code>[00:00:00.003,753] &lt;inf&gt; foundries_io_mod: initialized; getting help.
</code></pre><p>If we set <code>CONFIG_FOUNDRIES_IO_MOD_LOG_LEVEL=0</code> (NONE), no logs are
printed from this module.</p><h2 id=run-time-advanced>Run Time (Advanced)</h2><p>Logger also supports run time filtering. One use for this could be to
enable more verbose logs in response to some input or condition, to
collect detailed reports from misbehaving devices without cluttering
the logs on devices that are performing correctly.</p><p>Run time filtering is a somewhat advanced topic, with a few sharp edges:</p><ul><li>Since it increases program size and involves a performance penalty,
it is disabled by default, and must be turned on by enabling
<a href=http://docs.zephyrproject.org/reference/kconfig/CONFIG_LOG_RUNTIME_FILTERING.html>CONFIG_LOG_RUNTIME_FILTERING</a> before use.
Otherwise, attempts to change filter settings are silently ignored.
(It would be nice if these APIs returned errors instead in that
case.)</li><li>The <code>log_filter_set()</code> routine, which is used to control
run time filter settings, requires digging into some currently
unused/internal state in the Logger subsystem. (We&rsquo;ve hidden these
details in a helper; it would be nice if Logger itself had a simple
wrapper for the basic &ldquo;single core, this module&rdquo; case.)</li><li>Changing a module&rsquo;s filter settings at runtime is orthogonal to its
outstanding messages actually getting processed. This can lead to
surprising results depending on the times when: 1. messages are
logged, 2. filters are changed, and 3. the background processing
thread actually runs. (We work around this by waiting for all logs
to get flushed before changing the filter.)</li></ul><p>(Maybe you&rsquo;ll improve this situation and contribute your patches upstream?)</p><p>Example (<a href=https://github.com/foundriesio/zephyr-logging-examples/tree/1.13/logger_module_runtime>full source on GitHub</a>)</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>func</span>()
{
	<span style=color:#998;font-style:italic>/* Log a couple of messages. */</span>
	LOG_INF(<span style=color:#d14>&#34;for your information&#34;</span>);
	LOG_DBG(<span style=color:#d14>&#34;no bugs here!&#34;</span>);

	<span style=color:#998;font-style:italic>/* Wait for them to get processed. */</span>
	wait_for_log_processing();
}

<span style=color:#458;font-weight:700>void</span> <span style=color:#900;font-weight:700>main</span>(<span style=color:#458;font-weight:700>void</span>)
{
	printk(<span style=color:#d14>&#34;All logs disabled:</span><span style=color:#d14>\n</span><span style=color:#d14>&#34;</span>);
	set_my_log_level(LOG_LEVEL_NONE);
	func();

	printk(<span style=color:#d14>&#34;INF and up enabled:</span><span style=color:#d14>\n</span><span style=color:#d14>&#34;</span>);
	set_my_log_level(LOG_LEVEL_INF);
	func();

	printk(<span style=color:#d14>&#34;All logs enabled:</span><span style=color:#d14>\n</span><span style=color:#d14>&#34;</span>);
	set_my_log_level(LOG_LEVEL_DBG);
	func();
}</code></pre></div><p>Output:</p><pre><code>***** Booting Zephyr OS v1.12.0-1181-g55327a183 *****
All logs disabled:
INF and up enabled:
[00:00:00.007,263] &lt;inf&gt; foundries_io_mod_runtime: for your information
All logs enabled:
[00:00:01.015,960] &lt;inf&gt; foundries_io_mod_runtime: for your information
[00:00:01.015,960] &lt;dbg&gt; foundries_io_mod_runtime: no bugs here!
</code></pre><h1 id=quirks-and-gotchas>Quirks and Gotchas</h1><h2 id=grab-bag>Grab Bag</h2><p>The Logger subsystem has a few surprises (especially if you&rsquo;re used to
SYS_LOG), some of which we&rsquo;ve mentioned above:</p><ul><li><strong>Module names</strong>: Logger&rsquo;s macro metaprogramming uses module names in
C identifiers, which means they can&rsquo;t be arbitrary strings. Sticking
to valid C identifiers is best, though we&rsquo;ve found that leading
digits didn&rsquo;t pose a problem.</li><li><strong>Timestamp accuracy</strong>: Logger won&rsquo;t replace your scope. Timestamps
are displayed to the microsecond, but as we&rsquo;ve seen earlier, there&rsquo;s
no guarantee they are accurate to the microsecond. Be aware of this
before relying on them for precise measurements.</li><li><strong>Processing delays</strong>: By default, Logger takes up to a second
before processing logs. You can tune this, but the defaults can surprise.</li><li><strong>Complex run time filtering</strong>: the run time filtering mechanism
has some sharp edges, as discussed in above sections.</li><li><strong>Starvation</strong>: By default, the Logger background thread is low
priority, so it doesn&rsquo;t interfere with your system. If the system is
under heavy load, however, that means the thread could be starved
and logs might not print, the pool of messages might become empty,
causing lost messages, etc.</li></ul><p>A couple of additional quirks deserve sections of their own.</p><h2 id=logging-strings>Logging Strings</h2><p>Unlike the binary data dumping routines, logging strings which can
change between log creation time and processing time doesn&rsquo;t work the
way you&rsquo;d expect. Logger doesn&rsquo;t copy string data when buffering log
messages (since it doesn&rsquo;t inspect format strings at all, to save
time), so it&rsquo;s not safe to change a string after you&rsquo;ve passed a
pointer to it to Logger.</p><p>If you really need to log a mutable string, consider using the binary
data dumping routines described above as a hackaround, since they copy
the data and include ASCII output.</p><h2 id=overflow>Overflow</h2><p>Since logger has a fixed-size pool for buffering log messages, it&rsquo;s
possible to run out of room. When that happens, Logger has two choices:</p><ol><li>throw away old messages to make room to buffer new ones</li><li>throw away new messages until old ones are processed</li></ol><p>The default is option 1, which can be enforced by setting
<code>CONFIG_LOG_MODE_OVERFLOW=y</code>. The alternative can be chosen by
setting <code>CONFIG_LOG_MODE_NO_OVERFLOW=y</code>.</p><p>If you have space, you can also increase the pool size by increasing
<code>CONFIG_LOG_MSG_SIZE</code>. You can also try to use compile or run time
filtering to decrease the number of logged messages you don&rsquo;t care
about (though be aware that just enabling run time filtering carries a
footprint penalty of its own).</p><h1 id=summary>Summary</h1><p>The Logger subsystem has a tiered architecture with a fairly complex
set of features designed to allow logs to be created and buffered with
minimum latency, and processed later, with a sophisticated set of
filtering and tuning knobs.</p><p>This extra complexity has important benefits:</p><ul><li><strong>Low Latency</strong>: log messages can be buffered in a matter of microseconds,
making them much safer to use in interrupts, latency-sensitive threads, etc.</li><li><strong>Thread safety</strong>: log messages are created from a thread-safe buffer
pool and reference counted, so there&rsquo;s no risk that logging from two threads
will cause garbled output, and memory is returned to the pool when no longer
in use.</li><li><strong>Run time filtering</strong>: This feature, absent from SYS_LOG, is enabled
in Logger through explicitly managing extra state associated with modules
and instances.</li><li><strong>Backend support</strong>: Logger was designed for expansion, so network
and nonvolatile storage logging backends are sure to make an
appearance in the future.</li><li><strong>Multi-processor ready</strong>: Logger will enable safe logs in multi-processor
Zephyr systems.</li></ul><p>It also has important drawbacks compared to the simplicity of SYS_LOG:</p><ul><li><strong>More complex APIs</strong>: the introduction of &ldquo;source&rdquo; and &ldquo;domain&rdquo; IDs,
necessary to make Logger work, can make for clumsy usage in simple cases.</li><li><strong>Memory overhead</strong>: Logger&rsquo;s use of a message pool which copies log data
is a space for speed tradeoff.</li><li><strong>Scheduling considerations</strong>: SYS_LOG messages go out at the call site,
no questions asked. Deferred logging implies making sure the processing
thread neither starves or adds too much system overhead.</li><li><strong>Extra quirks</strong>: Logger can be something of a leaky abstraction, with a
few quirks to be aware of as discussed throughout the article.</li></ul><h1 id=additional-resources>Additional Resources</h1><p>Upstream Zephyr Logger documentation:</p><ul><li><a href=http://docs.zephyrproject.org/subsystems/logging/logger.html>Logger subsystem docs</a></li><li><a href=http://docs.zephyrproject.org/api/logger_api.html>Logger Doxygen API docs</a></li></ul></div><div id=comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"foundriesio"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div><div class=row><div class="small-12 columns"><div class=post-categories><div class="panel panel-default sidebar-menu"><div class=panel-heading><h3 class=panel-title>Categories</h3></div><div class=panel-body><ul class="nav nav-pills nav-stacked"><li><a href=https://foundries.io/categories/blockchain>blockchain (1)</a></li><li><a href=https://foundries.io/categories/conferences>conferences (4)</a></li><li><a href=https://foundries.io/categories/demos>demos (1)</a></li><li><a href=https://foundries.io/categories/fota>fota (8)</a></li><li><a href=https://foundries.io/categories/microplatform>microplatform (6)</a></li><li><a href=https://foundries.io/categories/news-and-media>news-and-media (5)</a></li><li><a href=https://foundries.io/categories/updates>updates (45)</a></li><li><a href=https://foundries.io/categories/zephyr-mp>zephyr-mp (2)</a></li><li><a href=https://foundries.io/categories/zephyr-news>zephyr-news (16)</a></li></ul></div></div><div class="panel sidebar-menu"><div class=panel-heading><h3 class=panel-title>Tags</h3></div><div class=panel-body><ul class=tag-cloud><li><a href=https://foundries.io/tags/ai><i class="fa fa-tags"></i>ai</a></li><li><a href=https://foundries.io/tags/assistant><i class="fa fa-tags"></i>assistant</a></li><li><a href=https://foundries.io/tags/att><i class="fa fa-tags"></i>att</a></li><li><a href=https://foundries.io/tags/ble><i class="fa fa-tags"></i>ble</a></li><li><a href=https://foundries.io/tags/blockchain><i class="fa fa-tags"></i>blockchain</a></li><li><a href=https://foundries.io/tags/bugs><i class="fa fa-tags"></i>bugs</a></li><li><a href=https://foundries.io/tags/container><i class="fa fa-tags"></i>container</a></li><li><a href=https://foundries.io/tags/containers><i class="fa fa-tags"></i>containers</a></li><li><a href=https://foundries.io/tags/crypto><i class="fa fa-tags"></i>crypto</a></li><li><a href=https://foundries.io/tags/cve><i class="fa fa-tags"></i>cve</a></li><li><a href=https://foundries.io/tags/decentralized><i class="fa fa-tags"></i>decentralized</a></li><li><a href=https://foundries.io/tags/demos><i class="fa fa-tags"></i>demos</a></li><li><a href=https://foundries.io/tags/docker><i class="fa fa-tags"></i>docker</a></li><li><a href=https://foundries.io/tags/docker-compose><i class="fa fa-tags"></i>docker-compose</a></li><li><a href=https://foundries.io/tags/edge><i class="fa fa-tags"></i>edge</a></li><li><a href=https://foundries.io/tags/fota><i class="fa fa-tags"></i>fota</a></li><li><a href=https://foundries.io/tags/foundries.io><i class="fa fa-tags"></i>foundries.io</a></li><li><a href=https://foundries.io/tags/google><i class="fa fa-tags"></i>google</a></li><li><a href=https://foundries.io/tags/iot><i class="fa fa-tags"></i>iot</a></li><li><a href=https://foundries.io/tags/k8s><i class="fa fa-tags"></i>k8s</a></li><li><a href=https://foundries.io/tags/kernel><i class="fa fa-tags"></i>kernel</a></li><li><a href=https://foundries.io/tags/keys><i class="fa fa-tags"></i>keys</a></li><li><a href=https://foundries.io/tags/kubernetes><i class="fa fa-tags"></i>kubernetes</a></li><li><a href=https://foundries.io/tags/linux><i class="fa fa-tags"></i>linux</a></li><li><a href=https://foundries.io/tags/lmp><i class="fa fa-tags"></i>lmp</a></li><li><a href=https://foundries.io/tags/lte><i class="fa fa-tags"></i>lte</a></li><li><a href=https://foundries.io/tags/lts><i class="fa fa-tags"></i>lts</a></li><li><a href=https://foundries.io/tags/lwm2m><i class="fa fa-tags"></i>lwm2m</a></li><li><a href=https://foundries.io/tags/management><i class="fa fa-tags"></i>management</a></li><li><a href=https://foundries.io/tags/mcuboot><i class="fa fa-tags"></i>mcuboot</a></li><li><a href=https://foundries.io/tags/media><i class="fa fa-tags"></i>media</a></li><li><a href=https://foundries.io/tags/microplatform><i class="fa fa-tags"></i>microplatform</a></li><li><a href=https://foundries.io/tags/open-source><i class="fa fa-tags"></i>open-source</a></li><li><a href=https://foundries.io/tags/ota><i class="fa fa-tags"></i>ota</a></li><li><a href=https://foundries.io/tags/portainer><i class="fa fa-tags"></i>portainer</a></li><li><a href=https://foundries.io/tags/press><i class="fa fa-tags"></i>press</a></li><li><a href=https://foundries.io/tags/radio><i class="fa fa-tags"></i>radio</a></li><li><a href=https://foundries.io/tags/resin><i class="fa fa-tags"></i>resin</a></li><li><a href=https://foundries.io/tags/security><i class="fa fa-tags"></i>security</a></li><li><a href=https://foundries.io/tags/update><i class="fa fa-tags"></i>update</a></li><li><a href=https://foundries.io/tags/whitepaper><i class="fa fa-tags"></i>whitepaper</a></li><li><a href=https://foundries.io/tags/zephyr><i class="fa fa-tags"></i>zephyr</a></li><li><a href=https://foundries.io/tags/zmp><i class="fa fa-tags"></i>zmp</a></li></ul></div></div></div></div></div></div></div><footer><div class=row><div class="columns small-12 medium-6"><div class=contacts><i class="fa fa-map-marker"></i>CAMBRIDGE, UK</div></div><div class="columns small-12 medium-6"><div class=contacts><i class="fa fa-map-marker"></i>SEATTLE, WA USA</div></div></div><div class="row footerlinks"><div class="columns small-12 medium-3 border-right"><h2>About Foundries.io</h2><p>Foundries.io is changing the IoT landscape by delivering continuously
updated software platforms for a secure, connected world.</p></div><div class="columns small-12 medium-3 border-right"><h2>Company</h2><ul><li><a href=https://foundries.io/company/>About</a></li><li><a href=https://foundries.io/careers/>Careers</a></li><li><a href=https://support.foundries.io/>Support</a></li><li><a href=https://foundries.io/labs/>Labs</a></li></ul></div><div class="columns small-12 medium-3 border-right"><h2>Connect</h2><ul class=social-links><li><a href=https://twitter.com/foundriesio><i class="fa fa-twitter fa-2x"></i></a></li><li><a href=https://www.linkedin.com/company/foundriesio/><i class="fa fa-linkedin fa-2x"></i></a></li><li><a href=https://github.com/foundriesio><i class="fa fa-github fa-2x"></i></a></li><li><a href=https://join.slack.com/t/foundriesio/shared_invite/enQtNTc5NDkxNTI5NTExLTU1YzI3YWFmZTI3ZjRjOTExZDZjYWFmMDNjZDBjYjczYTYzZWE0ZWYxYWVjMGZhYjNjN2MyMDVhMzY5NWNlNDE><i class="fa fa-slack fa-2x"></i></a></li></ul></div><div class="columns small-12 medium-3"><h2>Get Started Today</h2><p>Get immediate access to microPlatform source and binary builds for
today's most popular development boards by starting your subscription.</p></div></div><p class=copyright>Copyright 2018 &ndash; 2019 Foundries.io All rights reserved</p></footer><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-111281311-1','auto');ga('send','pageview');}</script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin=anonymous></script><script src=/js/vendor/wow.min.js></script><script src=/js/vendor/what-input.min.js></script><script src=/js/vendor/hoverIntent.js></script><script src=/js/vendor/jquery.responsiveTabs.js></script><script src=/js/vendor/superfish.min.js></script><script src=/js/vendor/owl.carousel.min.js></script><script src=/js/vendor/foundation.min.js></script><script src=/js/custom.min.js></script></body></html>